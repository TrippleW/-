#### 1、对一个桌子设计测试样例

**如何设计测试样例**：

1）询问面试官产品需求

2）功能测试、性能测试、界面测试、安全性测试、兼容性测试、可用性测试（是否符合人的使用习惯/方便使用等）、可靠性测试、本地化/国际化测试。

经典面试题：https://blog.csdn.net/slforeverlove/article/details/47080279

    需求测试：查看桌子相关的使用说明书。

    功能测试：桌子是办公用的还是放置东西用的，桌子的面积大小是否适合；

    界面测试：桌子的桌面是否平滑，有没有凹凸不平的地方；

    安全性测试：桌子的支撑点是否可靠；将桌子推倒后，它的损坏情况；

    压力测试：桌子可以承受的重量；

    可用性测试：桌子是否好移动；它的重量是否合适；

#### 2、双向链表的增删改查

``````C++

// 结点
typedef struct LNode {
    double data;
    struct LNode *prev;
    struct LNode *next;
}LNode, *LinkList

// 链表头
typedef struct List {
    LNode *head;
}List;

// 初始化结点
LNode* ListNodeInit(int n) {
    LNode* cur = (LNode*)malloc(sizeof(LNode));
    cur->data = n;
    cur->next = null;
    cur->prev = null;
}

// 初始化双向链表
void ListInit(List* pcl) {
    LNode *head = ListNodeInit(0);
    pcl->head = head;
    pcl->head->next = pcl->head;
    pcl->head->prev = pcl->head;
}

// 销毁链表
void ListDestroy(List* pcl){
    LNode *cur = pcl->head->next;
    while(cur!=pcl->head) {
        LNode* tmp = cur->next;
        free(cur);
        cur = tmp;
    }
    free(pcl->head);
    pcl->head = NULL;
}

// 在指定位置前面插入结点
void ListInsert(LNode* pos, double x) {
    LNode* newNode = ListNodeInit(x);
    // 保存前面结点
    LNode* prev = pos->prev;
    prev->next = newNode;
    newNode->prev = prev;
    newNode->next = pos;
    pos->prev = newNode;
}

// 指定位置删除结点
void ListErase(List* pcl, LNode* pos) {
    if(pos == pcl->head) {
        pcl->head = pos->next;
    }
    LNode *prev = pos->prev;
    LNode *next = pos->next;
    prev->next = next;
    next->prev = prev;
    free(pos);
}

// 寻找指定数据的结点
LNode* findListNode(List* pcl, double x) {
    LNode *cur = pcl->head->next;
    while(cur!=pcl->head) {
        if(cur->data == x) {
            return cur;
        }
        cur = cur->next;
    }
    return null;
}

// 改
LNode* editListNode(List *pcl, double x1, double x2) {
    LNode *res = findLsitNode(x1);
    if(res) res->data = x2;
}
``````

#### 3、linux操作系统 命令

    ls：查看当前目录下的文件及文件权限
    ll：ls ll，查看当前目录下的文件及其详细信息
    pwd：查看当前目录的绝对路径
    cd：目录间的移动
    mkdir：创建文件夹
    rm：删除文件或目录
    rmdir：删除目录（不能删除非空目录）
    mv：移动文件或者修改文件名  mv test.log test1.txt
    touch：创建文件

#### 4、TCP 三次握手四次挥手

https://blog.csdn.net/qq_38950316/article/details/81087809

#### 5、视图和表的区别 索引的优缺点

**视图和表的区别：**

数据库中的数据都是存储在表中的，而视图只是一个或多个表依照某个条件组合而成的结果集。

视图不占实际的空间物理，而表中的记录需要占物理空间。

建立和删除视图只影响视图本身，不会影响实际的记录。而建立和删除表会影响实际的记录。

对于可更新的视图，进行update，insert和delete等操作最终会作用于与其相关的表中数据。

**索引的优缺点：**

优点：
建立索引，可以大大提高系统的性能。
通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 
建立索引可以有效缩短数据的检索时间。
建立索引可以加快表与表之间的连接。
为用来排序或者是分组的字段添加索引可以加快分组和排序顺序。

缺点：
创建索引和维护索引需要时间成本，这个成本随着数据量的增加而加大
创建索引和维护索引需要空间成本，每一条索引都要占据数据库的物理存储空间，数据量越大，占用空间也越大（数据表占据的是数据库的数据空间）
会降低表的增删改的效率，因为每次增删改索引需要进行动态维护，导致时间变长

什么样的表需要建立索引：
数据量大的，经常进行查询操作的表
表中字段建立索引应该遵循的原则：
&nbsp; &nbsp; 越小的数据类型越好，简单的数据类型更好，尽量避免NULL，对唯一性更高的字段建立索引。
表与表连接用于多表联合查询的约束条件的字段应该建立索引。
用于排序的字段可以添加，用于分组的字段应该视情况添加。
如果有些表注定只会进行查询所有，没必要添加索引。

#### 6、黑盒测试方法 场景法

**黑盒测试**又称功能测试或数据测试，是从软件的外部对软件实施测试，也常形容为闭着眼睛测试。<br>
常用方法有，等价类划分法；边界值分析法；因果图法；场景法；正交实验设计法；判定表驱动分析法；错误推测法；功能图分析法。

##### 1）等价类划分测试

完全不考虑程序内部结构，只根据软件的要求和说明，把程序输入域划分成若干个部分，然后从每个部分中选取少数有代表性的数据作为测试输入。

分两步：确定等价类，确定测试用例。

##### 2）边界值分析

大量的故障往往发生在输入定义域或输出值域的边界上。
选取等于，刚刚大于或刚刚小于边界的值作为测试数据。

##### 3）决策表

决策表通常由4部分组成：条件桩、条件项、动作桩和动作项。

条件桩分列出问题的所有条件，除了某些问题对条件的先后次序有特定的要求外，通常在这里列出的条件其先后次序无关紧要。
条件项部分对条件桩给出的条件列出所有可能的取值。
动作桩则给出了问题规定的可能采取的操作，这些操作的排列顺序一般没有什么约束。
动作项指出在条件项的各组取值情况下应采取的动作。

把任何一个条件组合的特定取值及相应要执行的动作称为一条规则，在决策表中贯穿条件项和动作项的一列就是一条规则。显然，决策表中列出多少组条件取值，就有多少条规则。

若表中有两条或多条规则具有相同的动作，并且在条件项之间存在着极为相似的关系，便可以设法将其合并。

结合三角形问题给出构造决策表的5个步骤如下：
（1）确定规则的个数。例如，三角形问题的决策表有4个条件，每个条件可以取两个值，故应有16种规则。
（2）列出所有的条件桩和动作桩。
（3）填入条件项。
（4）填入动作项，这样便可得到初始决策表。
（5）简化。

##### 5）因果图

如果在测试时必须考虑输入条件的各种组合，可能的组合数将是一个天文数字，因此必须考虑使用一种适合于描述多种条件的组合，产生多个相应动作的测试方法，这就需要因果图。

##### 6）特殊值测试

##### 7）故障猜测法

列出程序中所有可能出现的故障或容易发生故障的情况，然后根据它们开发测试用例。

##### 8）场景法

针对需求模拟出不同的场景进行所有功能点及业务流程的覆盖。
适用于解决业务流程清晰的系统或功能。

#### 7、web端测试需要注意的地方 （浏览器兼容性、响应时间）

##### 1）页面部分

页面是否显示完整；<br>
页面在不同分辨率下、不同浏览器的不同版本中是否正常显示；<br>
页面在调整了浏览器窗口大小后，是否正常显示。<br>
页面的特殊效果（动图、特殊字体效果）是否显示。<br>
页面的特殊效果是否正确显示。<br>
页面在移动端网页的显示。

##### 2）易用性

Tab键、Enter键、Esc键的使用。<br>
提示信息是否友好。<br>
前进和后退：用户前进和后退有可能会造成数据不完整的提交，重复提交，或者其他的显示问题。<br>
所有键盘输入的特殊符号，都能正常保存。<br>
记住用户名功能。

##### 3）安全性：

不把密码等敏感的用户信息明文显示在url中。<br>
用户名和密码加密后在发送至web服务器。<br>
输入框应该防止SQL注入，防止XSS攻击。<br>
登录后生成的Cookie应该设置为httponly，且有过期时间。<br>

##### 4）性能测试

连接速度测试<br>
负载测试<br>
压力测试：实际破坏一个Web应用系统，测试系统的反映。压力测试是测试系统的限制和故障恢复能力，也就是测试Web应用系统会不会崩溃，在什么情况下会崩溃。黑客常常提供错误的数据负载，直到Web应用系统崩溃，接着当系统重新启动时获得存取权。压力测试的区域包括表单、登陆和其他信息传输页面等。 <br>


#### 8、vi怎么查找 怎么替换

https://www.cnblogs.com/longjshz/p/5775584.html

**查找：**

`/pattern<Enter>`：向下查找pattern匹配字符串<br>
`?pattern<Enter>`：向上查找pattern匹配字符串

使用了查找命令之后，使用如下两个键快速查找： <br>
n：按照同一方向继续查找 <br>
N：按照反方向查找 <br>

**替换：**

``````
:s/vivian/sky/         #替换当前行第一个 vivian 为 sky

:s/vivian/sky/g     #替换当前行所有 vivian 为 sky

:n,$s/vivian/sky/     #替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky

:n,$s/vivian/sky/g     #替换第 n 行开始到最后一行中每一行所有 vivian 为 sky
  （n 为数字，若 n 为 .，表示从当前行开始到最后一行）

:%s/vivian/sky/        #（等同于:1,$s/vivian/sky/   :g/vivian/s//sky/） 替换每一行的第一个 vivian 为 sky

:%s/vivian/sky/g #（等同于:1,$s/vivian/sky/g     :g/vivian/s//sky/g）替换每一行的所有 vivian 为 sky

``````

可以使用 #或+ 作为分隔符，此时中间出现的 / 不会作为分隔符 

``````
:s#vivian/#sky/#         替换当前行第一个 vivian/ 为 sky/
:%s+/oradata/apras/+/user01/apras1+ （使用+ 来 替换 / ）： /oradata/apras/替换成/user01/apras1/
``````

#### 9、希尔排序 二分插入排序 直接插入排序

https://www.cnblogs.com/onepixel/articles/7674659.html

直接插入排序： 

时间复杂度：平均，O(n^2)；最坏，O(n^2)；最好，O(n)<br>
空间复杂度：O(1)<br>
稳定

``````javascript

function insertSort(arr) {
    var len = arr.length;
    for(var i=2;i<=len;i++) {
        arr[0] = arr[i];
        var j = i-1;
        while(arr[0]<arr[j]) {
            arr[j+1] = arr[j];
            j = j-1;
        }
        arr[j+1] = arr[0];
    }
    return arr;
}

``````

希尔排序：

时间复杂度：平均，O(n^1.3)；最坏，O(n^2)；最好，O(n)<br>
空间复杂度：O(1)<br>
不稳定

``````javascript

function shellSort(arr) {
    var len = arr.length;
    for(var gap = Math.floor(len/2); gap>0; gap = Math.floor(gap/2)){
        for(var i=gap;i<len;i++) {
            var j = i;
            var current = arr[i];
            while(j-gap>=0 && current<arr[j-gap]) {
                arr[j] = arr[j-gap];
                j = j-gap;
            }
            arr[j] = current;
        }
    }
    return arr;
}

``````

二分插入排序

``````javascript

function binaryInsertSort(arr) {
    var len = arr.length;
    var key = 0;
    var low = high = low = 0;
    for(var i = 1;i<len;i++) {
        key = arr[i];
        low = 0;
        high = i-1;
        while(low<=high) {
            mid = (high+low)/2;
            if(key<arr[mid]) high = mid-1;
            else low = mid+1;
        }
        for(var j=i-1;j>=high+1;j--) {
            arr[j+1] = arr[j];
        }
        arr[high+1] = key;
    }
}

``````

#### 10、对测试的认识

测试是对产品质量的检验和评价。它一方面检查产品中存在的质量问题，另一方面对产品质量进行客观的评价。

对于相对复杂的产品或系统来说，测试遵循Good-Enough原则，权衡投入和产出比。

测试的所有标准都是建立在用户需求上的。

软件测试必须基于“质量第一”的思想去开展各项工作，当时间和质量冲突时，时间要服从质量。

事先定义好产品的质量标准。

项目一启动，测试也就开始，而不是等程序写完，才开始进行测试。

穷举测试是不可能的。、

第三方进行测试会更客观，更有效。

软件测试计划是做好软件测试工作的前提。

测试用例是设计出来的，不是写出来的，所以要根据测试的目的，采用相应的方法去设计测试用例，从而提高测试的效率，更多地发现错误，提高程序的可靠性。

不可将测试用例置之度外，排除随意性。

对发现错误较多的程序段，应进行更深入的测试。

#### 11、自动化测试

自动化包括一切通过工具（程序）的方式来代替或辅助手工测试的行为都可以看做自动化，包括性能测试工具（loadrunner、jmeter）,或自己所写的一段程序，用于生成1到100个测试数据。<br>
狭义上来讲，通过工具记录或编写脚本的方式模拟手工测试的过程，通过回放或运行脚本来执行测试用例，从而代替人工对系统的功能进行验证。

当然，我们更普遍的认识把“自动化测试”看做“ 基于产品或项目UI层的自动化测试”。

优势：
提高测试执行效率，节约时间成本；
解放人力去做更重要的工作；
可重复利用，减少对人的依赖；
提升客户满意度；
提升测试团队的整体水平；
可大幅度减少兼容性测试的工作量；
有些测试工作必须依靠自动化实现来完成。

劣势：
开发测试脚本需要花费较大的时间成本，拉长周期;
产品的快速迭代，自动化脚本也将不断迭代，时间成本很高;
不同的项目之间自动化脚本的复用度很低;
对短期型项目产品实现自动化价值不高;
自动化无法完全代替手工测试找到bug，实现100%覆盖;
自动化更多的适用于回归测试;
自动化开发过程对软件测试团队的技术有更高的要求;


#### 12、扫地机器人 分析

    需求测试：查看扫地机器人的相关使用说明书。
    
    功能测试：扫地机器人能否将地上的垃圾清理干净。

    性能测试：测试清洁率，地板清洁能力测试，沿边清扫能力测试，障碍测试，地毯清洁能力测试，宠物猫测试，毛发缠绕测试。

    界面测试：扫地机器人的设计是否符合人的审美

    安全性测试：防跌落测试、防漏电测试

    可用性测试：噪音测试

#### 13、白盒测试

又称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。

##### 1）语句覆盖

使程序中的每个可执行语句至少执行一次。

优：可直观地从源代码得到测试用例，无须细分每条判定表达式。

缺：对于隐藏条件和可能到达地隐式逻辑分支，无法测试。

##### 2）判定覆盖

使得程序中每个判断地取真分支和取假分支至少经历一次。

缺：仅判断条件结果，忽略每个条件的取值情况，会遗漏部分测试路径。

##### 3）条件覆盖

使得判断语句里面每个条件表达式true和false各取值一次。

缺：只保证每个条件都取到了不同结果，没有考虑判定结果。因此有时候条件覆盖不能保证判定覆盖。

##### 4）判定条件覆盖

使得每个条件所有可能取值至少执行一次，同时每个判断本身所有结果至少执行一次。

缺：并未考虑条件组合情况。

##### 5）组合覆盖

条件组合覆盖，使得每个判定中的各个条件的各种可能组合都至少出现一次。

缺：覆盖率较高，但测试用例数量相对来说也比较多。

##### 6）路径覆盖

测试用例可以覆盖程序中所有可能的执行路径。

缺：需要设计数量非常巨大且较为复杂的测试用例。

